(define (make-table)
  (let ((local-table (list '*table*)))
    (define (lookup keys)
      (define (recursive keys table)
	(if (null? keys)
	    table
	    (let ((subtable
		   (assoc
		    (car keys)
		    table)))
	      (if subtable
		  (recursive
		   (cdr keys)
		   (cdr subtable))
		  #f))))
      (if (null? keys)
	  (error "Keys should not be null")
	  (recursive keys (cdr local-table))))
    (define (insert! keys value)
      (define (recursive keys table)
	(if (and (not (pair? (cdr table)))
		 (not (null? (cdr table))))
	    (set-cdr! table '()))	;overwrittern the key-value with new table
	(let ((subtable (assoc
			 (car keys)
			 (cdr table)))
	      (left (cdr keys))
	      (first (car keys))
	      (left-tables (cdr table)))
	  (cond ((and subtable (null? left))
		 (set-cdr! subtable value)
		 'ok)
		((and subtable (not (null? left)))
		 (recursive left subtable))
		((and (not subtable) (not (null? left)))
		 (let ((sub (cons first '())))
		   (set-cdr! table (cons sub left-tables))
		   (recursive left sub)))
		((and (not subtable) (null? left))
		 (let ((sub (cons first value)))
		   (set-cdr! table (cons sub left-tables))
		   'ok)))))
      (if (null? keys)
	  (error "Keys should not be null")
	  (recursive keys local-table)))
    (define (assoc key records)
      (cond ((null? records) #f)
	    ((equal? key (caar records)) (car records))
	    (else (assoc key (cdr records)))))
    (define (dispatch m)
      (cond ((eq? m 'lookup-proc) lookup)
	    ((eq? m 'insert-proc!) insert!)
	    (else (error "Unknown operation -- TABLE" m))))
    dispatch))
